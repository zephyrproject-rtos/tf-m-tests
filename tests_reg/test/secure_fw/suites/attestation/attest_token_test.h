/*
 * attest_token_test.h
 *
 * Copyright (c) 2018-2019, Laurence Lundblade.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * See BSD-3-Clause license in README.md
 */

#ifndef __ATTEST_TOKEN_TEST_H__
#define __ATTEST_TOKEN_TEST_H__

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \file attest_token_test.h
 *
 * \brief Entry points for attestation token tests.
 *
 * Errors codes are in the range of [-32767,32767] so
 * int_fast16_t is used so they will work nice
 * even on 16-bit machines. Plain old int could
 * also be used, but many compilers make it
 * 32-bits for backwards compatibility with
 * SW that assume it is always 32 bits and
 * it isn't efficient.  (This code has probably
 * not yet been tested on a 16-bit machines).
 *
 * https://stackoverflow.com/questions/30942107/
 * whats-the-difference-between-int-and-int-fast16-t
 */


#ifdef SYMMETRIC_INITIAL_ATTESTATION
/**
 * \brief Test by checking token generated by symmetric key algorithms based
 *        Initial Attestation.
 *
 * \return non-zero on failure.
 *
 * This is an extensive test that can compare the values in the token
 * to expected valued compiled into the test app from
 * token_test_values.h. All the values represented in \ref
 * attest_token_iat_simple_t and in \ref attest_token_sw_component_t
 * are checked.
 *
 * The generated token will be decoded.
 * The tag in COSE_Mac0 structure will be verified in secure side when
 * INCLUDE_TEST_CODE is enabled.
 */
int_fast16_t decode_test_symmetric_initial_attest(void);

#else /* SYMMETRIC_INITIAL_ATTESTATION */

/**
 * \brief Test by checking signed values of claims.
 *
 * \return non-zero on failure.
 *
 * This is an extensive test that can compare the values in the token
 * to expected valued compiled into the test app from
 * token_test_values.h. All the values represented in \ref
 * attest_token_iat_simple_t and in \ref attest_token_sw_component_t
 * are checked.
 *
 * This uses real ECDSA keys for both signing and verification.  It
 * requires that the t_cose crypto porting layer operates correctly
 * and that all keys are present.
 */
int_fast16_t decode_test_normal_sig(void);
#endif /* SYMMETRIC_INITIAL_ATTESTATION */

#ifdef __cplusplus
}
#endif

#endif /* __TOKEN_TEST_H__ */
